// DO NOT EDIT THIS FILE!
// It is generated by `light` tool from source `{{.Source}}`.

package {{.Name}}

import (
    "bytes"
    "encoding/json"
    "fmt"
    "database/sql"
    "github.com/arstd/log"
    "github.com/arstd/light/light"
	"github.com/lib/pq"
    {{.ImportsExpr}}
)

{{- range .Interfaces}}
    {{- $itf := .}}

    type {{$itf.Title}}Impl struct{}

    {{- range .Methods}}
        func (*{{$itf.Title}}Impl) {{.Name}}({{.ParamsExpr}})({{.ResultsExpr}}) {
            var (
                exec  light.Execer = light.GetExecer({{$.DBVar}}, xtx)
                xbuf  bytes.Buffer
                xargs []interface{}
            )
            {{- block "fragments" .Fragments}}
                {{- range .}}
                    {{- if .Hashtag}}
                        xbuf.WriteString(fmt.Sprint({{(index .Args 0).Var}})+" ")
                    {{- else}}
                        {{- if .Range}}
                            for {{.Index.Var}}, {{.Iterator.Var}} := range {{.Range.Var}} {
                                if {{.Index.Var}} != 0 {
                                    xbuf.WriteString("{{.Seperator}} ")
                                }
                        {{- else if .Cond}}
                            if {{.Cond}} {
                        {{- end}}

                                {{- if .Prepare}}
                                    xbuf.WriteString(`{{.Prepare}} `)
                                {{- end}}

                                {{- if .Args}}
                                    xargs = append(xargs
                                {{- end}}
                                {{- range .Args}}
                                    {{- if eq .Name "int32"}} ,light.Time({{.Var}})
                                    {{- else if .PGArray}} ,pq.Array({{.Var}})
                                    {{- else if .Complex}} ,light.JSON({{.Var}})
                                    {{- else}} ,{{- .Var}}
                                    {{- end}}
                                {{- end}}
                                {{- if .Args}} ) {{- end}}

                                {{- template "fragments" .Fragments}}
                        {{- if .Range}}
                            }
                        {{- else if .Cond}}
                            }
                        {{- end}}
                    {{- end}}

                {{- end}}{{/* end range fragments */}}
            {{- end}}{{/* end fragments block */}}

            xholder := make([]interface{}, len(xargs))
            for i := range xargs {
                xholder[i] = fmt.Sprintf("$%d", i+1)
            }
            xquery := fmt.Sprintf(xbuf.String(), xholder...)

            {{- if ne .Kind "page"}}
                log.Debug(xquery)
                log.JSON(xargs...)
            {{end}}

            {{- if or (eq .Kind "batch") (eq .Kind "update") (eq .Kind "delete")}}
                var xres sql.Result
                xres, err = exec.Exec(xquery, xargs...)
                if err != nil {
                    log.Error(xquery)
                    log.Error(xargs...)
                    log.Error(err)
                    return
                }
                return xres.RowsAffected()
            {{- /* end batch method */}}

            {{- else if or (eq .Kind "get") (eq .Kind "insert")}}
                {{- if eq .Kind "get"}}
                    {{.Return.Var}} = {{.Return.MakeExpr}}
                {{- end}}
                {{- $Return := .Return}}
                xdest := []interface{}{
                {{- range $i, $r := .Returnings}}
                    {{- if eq $r.Name "int32"}}light.Time(&{{$Return.Var}}.{{$r.Var}}),
                    {{- else if .PGArray}}pq.Array(&{{$Return.Var}}.{{$r.Var}}),
                    {{- else if .Complex}}light.JSON(&{{$Return.Var}}.{{$r.Var}}),
                    {{- else}}&{{$Return.Var}}.{{$r.Var}},
                    {{- end}}
                {{- end}} }
                err = exec.QueryRow(xquery, xargs...).Scan(xdest...)
                if err != nil {
                    {{- if eq .Kind "get"}}
                        if err == sql.ErrNoRows {
                            return nil, nil
                        }
                    {{- end}}
            		log.Error(err)
            		log.Error(xquery)
            		log.Error(xargs...)
            	}
                return
            {{- /* end batch method */}}

            {{- else if eq .Kind "list"}}
                var xrows *sql.Rows
                xrows, err = exec.Query(xquery, xargs...)
                if err != nil {
                    log.Error(xquery)
                    log.Error(xargs...)
                    log.Error(err)
                    return
                }
                defer xrows.Close()

                {{.Return.Var}} = {{.Return.MakeExpr}}
                for xrows.Next() {
                    xe := {{.Return.MakeElemExpr}}
                    {{.Return.Var}} = append({{.Return.Var}}, xe)
                    xdest := []interface{}{
                    {{- range $i, $r := .Returnings}}
                        {{- if eq $r.Name "int32"}}light.Time(&xe.{{$r.Var}}),
                        {{- else if .PGArray}}pq.Array(&xe.{{$r.Var}}),
                        {{- else if .Complex}}light.JSON(&xe.{{$r.Var}}),
                        {{- else}}&xe.{{$r.Var}},
                        {{- end}}
                    {{- end}} }
                    err = xrows.Scan(xdest...)
                    if err != nil {
                        log.Error(err)
                        return
                    }
                }
                if err = xrows.Err(); err != nil {
                    log.Error(err)
                }
                return
            {{- /* end batch method */}}

            {{- else if eq .Kind "count"}}
                err = exec.QueryRow(xquery, xargs...).Scan(&{{.Return.Var}})
                if err != nil {
                    log.Error(xquery)
                    log.Error(xargs...)
                    log.Error(err)
                }
                return
            {{- /* end count method */}}

            {{- else if eq .Kind "page"}}

                xfindex := strings.Index(xquery, " from ")
                xobindex := strings.LastIndex(xquery, "order by")
                xtquery := `select count(*)` + xquery[xfindex:xobindex]
                xdcnt := strings.Count(xquery[xobindex:], "$")
                xtargs := xargs[:len(xargs)-xdcnt]
                log.Debug(xtquery)
                log.JSON(xtargs...)

                err = exec.QueryRow(xtquery, xtargs...).Scan(&{{(index .Results 0).Var}})
                if err != nil {
                    log.Error(xtquery)
                    log.Error(xtargs...)
                    log.Error(err)
                    return
                }
                if {{(index .Results 0).Var}} == 0 {
                    return
                }

                log.Debug(xquery)
                log.JSON(xargs...)

                var xrows *sql.Rows
                xrows, err = exec.Query(xquery, xargs...)
                if err != nil {
                    log.Error(xquery)
                    log.Error(xargs...)
                    log.Error(err)
                    return
                }
                defer xrows.Close()

                {{.Return.Var}} = {{.Return.MakeExpr}}
                for xrows.Next() {
                    xe := {{.Return.MakeElemExpr}}
                    {{.Return.Var}} = append({{.Return.Var}}, xe)
                    xdest := []interface{}{
                    {{- range $i, $r := .Returnings}}
                        {{- if eq $r.Name "int32"}}light.Time(&xe.{{$r.Var}}),
                        {{- else if .PGArray}}pq.Array(&xe.{{$r.Var}}),
                        {{- else if .Complex}}light.JSON(&xe.{{$r.Var}}),
                        {{- else}}&xe.{{$r.Var}},
                        {{- end}}
                    {{- end}} }
                    err = xrows.Scan(xdest...)
                    if err != nil {
                        log.Error(err)
                        return
                    }
                }
                if err = xrows.Err(); err != nil {
                    log.Error(err)
                }
                return
            {{- /* end page method */}}

            {{- else}}
                {{.Kind}} template not implemented
            {{- end}}
        }
    {{end}}{{/* end range methods */}}
{{- end}}{{/* end range interfaces */}}
