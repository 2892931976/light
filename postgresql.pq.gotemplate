// DO NOT EDIT THIS FILE!
// It is generated by `light` tool from source `{{.Source}}`.

package {{.Name}}

import (
    "bytes"
    "encoding/json"
    "fmt"
    "github.com/arstd/log"
	"github.com/lib/pq"
    {{.ImportsExpr}}
)

{{- range .Interfaces}}
    {{- $itf := .}}

    type {{$itf.Name}}Impl struct{}

    {{- range .Methods}}
        // {{.Doc}}
        func (*{{$itf.Name}}Impl) {{.Name}}({{.ParamsExpr}})({{.ResultsExpr}}) {
            var (
                xbuf  bytes.Buffer
                xargs []interface{}
            )

            {{- block "fragments" .Fragments}}
                {{- range .}}
                    // {{.Stmt}}
                    {{- if .Range}}
                        for {{.Index.Var}}, {{.Iterator.Var}} := range {{.Range.Var}} {
                            if {{.Index.Var}} != 0 {
                                xbuf.WriteString("{{.Seperator}} ")
                            }
                    {{- else if .Cond}}
                        if {{.Cond}} {
                    {{- end}}
                            {{- if .Prepare}}
                                xbuf.WriteString(`{{.Prepare}} `)
                            {{- end}}

                            {{- range .Args}}
                                {{- if .PGArray}}
                                {{- else if .Complex}}
                                    {{.Var2}}, _ := json.Marshal({{.Var}})
                                {{- end}}
                            {{- end}}
                            {{- if .Args}}
                                xargs = append(xargs
                            {{- end}}
                            {{- range .Args}},
                                {{- if eq .Name "uint32"}}time.Unix(int64({{.Var}}),0)
                                {{- else if .PGArray}}pq.Array({{.Var}})
                                {{- else if .Complex}}{{- .Var2}}
                                {{- else}}{{- .Var}}
                                {{- end}}
                            {{- end}}
                            {{- if .Args}} ) {{- end}}

                            {{- template "fragments" .Fragments}}
                    {{- if .Range}}
                        }
                    {{- else if .Cond}}
                        }
                    {{- end}}

                {{- end}}{{/* end range fragments */}}
            {{- end}}{{/* end fragments block */}}

            xholder := make([]interface{}, len(xargs))
            for i := range xargs {
                xholder[i] = fmt.Sprintf("$%d", i+1)
            }
            xquery := fmt.Sprintf(xbuf.String(), xholder...)

            {{- if ne .Kind "page"}}
                log.Debug(xquery)
                log.Debug(xargs...)
            {{end}}

            {{- if or (eq .Kind "batch") (eq .Kind "update") (eq .Kind "delete")}}
                var xres sql.Result
                if len(xtx) > 0 {
                    xres, err = xtx[0].Exec(xquery, xargs...)
                } else {
                    xres, err = {{$.DBVar}}.Exec(xquery, xargs...)
                }
                if err != nil {
                    log.Error(xquery)
                    log.Error(xargs...)
                    log.Error(err)
                }
                return xres.RowsAffected()
            {{- /* end batch method */}}

            {{- else if or (eq .Kind "get") (eq .Kind "insert")}}
                {{- if eq .Kind "get"}}
                    {{.Return.Var}} = {{.Return.MakeExpr}}
                {{- end}}
                {{- $Return := .Return}}
                {{- range $i, $r := .Returnings}}
                    {{- if or (eq $r.Name "uint32") (and (eq $r.Pkg "time") (eq $r.Name "Time"))}}
                        var {{$Return.Var}}{{$r.Var2}} pq.NullTime
                    {{- else if .PGArray}}
                    {{- else if .Complex}}
                        var {{$Return.Var}}{{.Var2}} []byte
                    {{- end}}
                {{- end}}
                xdest := []interface{}{
                {{- range $i, $r := .Returnings}}
                    {{- if or (eq $r.Name "uint32") (and (eq $r.Pkg "time") (eq $r.Name "Time"))}}
                        &{{$Return.Var}}{{$r.Var2}},
                    {{- else if .PGArray}}pq.Array(&{{$Return.Var}}.{{$r.Var}}),
                    {{- else if .Complex}}&{{$Return.Var}}{{$r.Var2}},
                    {{- else}}&{{$Return.Var}}.{{$r.Var}},
                    {{- end}}
                {{- end}} }
                if len(xtx) > 0 {
                    err = xtx[0].QueryRow(xquery, xargs...).Scan(xdest...)
                } else {
                    err = {{$.DBVar}}.QueryRow(xquery, xargs...).Scan(xdest...)
                }
                if err != nil {
            		log.Error(err)
            		log.Error(xquery)
            		log.Error(xargs...)
            	}
                {{- range $i, $r := .Returnings}}
                    {{- if eq $r.Name "uint32"}}
                        {{$Return.Var}}.{{$r.Var}} = uint32({{$Return.Var}}{{$r.Var2}}.Time.Unix())
                    {{- else if and (eq $r.Pkg "time") (eq $r.Name "Time")}}
                        {{$Return.Var}}.{{$r.Var}} = {{$Return.Var}}{{$r.Var2}}.Time
                    {{- else if .PGArray}}
                    {{- else if .Complex}}
                        {{$Return.Var}}.{{$r.Var}} = {{$r.MakeExpr}}
                        json.Unmarshal({{$Return.Var}}{{.Var2}}, {{$r.VarPointerExpr}}{{$Return.Var}}.{{$r.Var}})
                    {{- end}}
                {{- end}}
                return
            {{- /* end batch method */}}

            {{- else if eq .Kind "list"}}
                var xrows *sql.Rows
                if len(xtx) > 0 {
                    xrows, err = xtx[0].Query(xquery, xargs...)
                } else {
                    xrows, err = {{$.DBVar}}.Query(xquery, xargs...)
                }
                if err != nil {
                    log.Error(err)
                    log.Error(xquery)
                    log.Error(xargs...)
                    return
                }
                defer xrows.Close()

                {{.Return.Var}} = {{.Return.MakeExpr}}
                for xrows.Next() {
                    xe := {{.Return.MakeElemExpr}}
                    {{.Return.Var}} = append({{.Return.Var}}, xe)
                    {{- range $i, $r := .Returnings}}
                        {{- if or (eq $r.Name "uint32") (and (eq $r.Pkg "time") (eq $r.Name "Time"))}}
                            var xe{{$r.Var2}} pq.NullTime
                        {{- else if .PGArray}}
                        {{- else if .Complex}}
                            var xe{{.Var2}} []byte
                        {{- end}}
                    {{- end}}
                    xdest := []interface{}{
                    {{- range $i, $r := .Returnings}}
                        {{- if or (eq $r.Name "uint32") (and (eq $r.Pkg "time") (eq $r.Name "Time"))}}&xe{{$r.Var2}},
                        {{- else if .PGArray}}pq.Array(&xe.{{$r.Var}}),
                        {{- else if .Complex}}&xe{{$r.Var2}},
                        {{- else}}&xe.{{$r.Var}},
                        {{- end}}
                    {{- end}} }
                    err = xrows.Scan(xdest...)
                    if err != nil {
                        log.Error(err)
                        return
                    }
                    {{- range $i, $r := .Returnings}}
                        {{- if eq $r.Name "uint32"}}
                            xe.{{$r.Var}} = uint32(xe{{$r.Var2}}.Time.Unix())
                        {{- else if and (eq $r.Pkg "time") (eq $r.Name "Time")}}
                            xe.{{$r.Var}} = xe{{$r.Var2}}.Time
                        {{- else if .PGArray}}
                        {{- else if .Complex}}
                            xe.{{$r.Var}} = {{$r.MakeExpr}}
                            json.Unmarshal(xe{{.Var2}}, {{$r.VarPointerExpr}}xe.{{$r.Var}})
                        {{- end}}
                    {{- end}}
                }
                if err = xrows.Err(); err != nil {
                    log.Error(err)
                }
                return
            {{- /* end batch method */}}

            {{- else if eq .Kind "count"}}
                if len(xtx) > 0 {
                    err = xtx[0].QueryRow(xquery, xargs...).Scan(&{{.Return.Var}})
                } else {
                    err = {{$.DBVar}}.QueryRow(xquery, xargs...).Scan(&{{.Return.Var}})
                }
                if err != nil {
                    log.Error(err)
                    log.Error(xquery)
                    log.Error(xargs...)
                }
                return
            {{- /* end count method */}}

            {{- else if eq .Kind "page"}}

                xfindex := strings.LastIndex(xquery, " from ")
                xobindex := strings.LastIndex(xquery, "order by")
                xtquery := `select count(*)` + xquery[xfindex:xobindex]
                xdcnt := strings.Count(xquery[xobindex:], "$")
                xtargs := xargs[:len(xargs)-xdcnt]
                log.Debug(xtquery)
                log.Debug(xtargs...)

                if len(xtx) > 0 {
                    err = xtx[0].QueryRow(xtquery, xtargs...).Scan(&{{(index .Results 0).Var}})
                } else {
                    err = {{$.DBVar}}.QueryRow(xtquery, xtargs...).Scan(&{{(index .Results 0).Var}})
                }
                if err != nil {
                    log.Error(err)
                    log.Error(xquery)
                    log.Error(xargs...)
                    return
                }
                if {{(index .Results 0).Var}} == 0 {
                    return
                }

                log.Debug(xquery)
                log.Debug(xargs...)

                var xrows *sql.Rows

                if len(xtx) > 0 {
                    xrows, err = xtx[0].Query(xquery, xargs...)
                } else {
                    xrows, err = {{$.DBVar}}.Query(xquery, xargs...)
                }
                if err != nil {
                    log.Error(err)
                    log.Error(xquery)
                    log.Error(xargs...)
                    return
                }
                defer xrows.Close()

                {{.Return.Var}} = {{.Return.MakeExpr}}
                for xrows.Next() {
                    xe := {{.Return.MakeElemExpr}}
                    {{.Return.Var}} = append({{.Return.Var}}, xe)
                    {{- range $i, $r := .Returnings}}
                        {{- if or (eq $r.Name "uint32") (and (eq $r.Pkg "time") (eq $r.Name "Time"))}}
                            var xe{{$r.Var2}} pq.NullTime
                        {{- else if .PGArray}}
                        {{- else if .Complex}}
                            var xe{{.Var2}} []byte
                        {{- end}}
                    {{- end}}
                    xdest := []interface{}{
                    {{- range $i, $r := .Returnings}}
                        {{- if or (eq $r.Name "uint32") (and (eq $r.Pkg "time") (eq $r.Name "Time"))}}&xe{{$r.Var2}},
                        {{- else if .PGArray}}pq.Array(&xe.{{$r.Var}}),
                        {{- else if .Complex}}&xe{{$r.Var2}},
                        {{- else}}&xe.{{$r.Var}},
                        {{- end}}
                    {{- end}} }
                    err = xrows.Scan(xdest...)
                    if err != nil {
                        log.Error(err)
                        return
                    }
                    {{- range $i, $r := .Returnings}}
                        {{- if eq $r.Name "uint32"}}xe.{{$r.Var}} = uint32(xe{{$r.Var2}}.Time.Unix())
                        {{- else if and (eq $r.Pkg "time") (eq $r.Name "Time")}}xe.{{$r.Var}} = xe{{$r.Var2}}.Time
                        {{- else if .PGArray}}
                        {{- else if .Complex}}
                            xe.{{$r.Var}} = {{$r.MakeExpr}}
                            json.Unmarshal(xe{{.Var2}}, {{$r.VarPointerExpr}}xe.{{$r.Var}})
                        {{- end}}
                    {{- end}}
                }
                if err = xrows.Err(); err != nil {
                    log.Error(err)
                }
                return
            {{- /* end page method */}}

            {{- else}}
                {{.Kind}} template not implemented
            {{- end}}
        }
    {{end}}{{/* end range methods */}}
{{- end}}{{/* end range interfaces */}}
