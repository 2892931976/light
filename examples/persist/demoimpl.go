// DO NOT EDIT THIS FILE !
// It is generated by persist tool, source from demo.go.
package persist

import (
	"bytes"
	"database/sql"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/arstd/gobatis/examples/domain"
	"github.com/arstd/gobatis/examples/enums"
	"github.com/wothing/log"
)

type DemoPersist struct{}

func (*DemoPersist) Add(d *domain.Demo) error {
	var err error
	query, args := bytes.NewBuffer([]byte{}), []interface{}{}
	var stmt string

	stmt = "insert into demos(name, third_field, status, content) values($%d, $%d, $%d, $%d) returning id "
	args = append(args, d.Name)
	args = append(args, d.ThirdField)
	args = append(args, int8(d.Status))
	d_Content, err := json.Marshal(d.Content)
	if err != nil {
		log.Errorf("marshal(%#v) error: %s", d.Content, err)
	}
	args = append(args, d_Content)
	query.WriteString(stmt)

	var dollar []interface{}
	for i := range args {
		dollar = append(dollar, i+1)
	}
	stmt = fmt.Sprintf(query.String(), dollar...)

	log.Debug(stmt)
	log.Debug(args...)

	dest := []interface{}{&d.Id}
	err = db.QueryRow(stmt, args...).Scan(dest...)
	if err != nil {
		log.Error(err)
		log.Error(stmt)
		log.Error(args...)
		return err
	}
	return nil

}

func (*DemoPersist) Modify(d *domain.Demo) (int64, error) {
	var err error
	query, args := bytes.NewBuffer([]byte{}), []interface{}{}
	var stmt string

	stmt = "update demos set name=$%d, third_field=$%d, status=$%d, content=$%d where id=$%d "
	args = append(args, d.Name)
	args = append(args, d.ThirdField)
	args = append(args, int8(d.Status))
	d_Content, err := json.Marshal(d.Content)
	if err != nil {
		log.Errorf("marshal(%#v) error: %s", d.Content, err)
	}
	args = append(args, d_Content)
	args = append(args, d.Id)
	query.WriteString(stmt)

	var dollar []interface{}
	for i := range args {
		dollar = append(dollar, i+1)
	}
	stmt = fmt.Sprintf(query.String(), dollar...)

	log.Debug(stmt)
	log.Debug(args...)
	res, err := db.Exec(stmt, args...)
	if err != nil {
		log.Error(err)
		log.Error(stmt)
		log.Error(args...)
		return 0, err
	}
	return res.RowsAffected()
}

func (*DemoPersist) Remove(id int) (int64, error) {
	var err error
	query, args := bytes.NewBuffer([]byte{}), []interface{}{}
	var stmt string

	stmt = "delete from demos where id=$%d "
	args = append(args, id)
	query.WriteString(stmt)

	var dollar []interface{}
	for i := range args {
		dollar = append(dollar, i+1)
	}
	stmt = fmt.Sprintf(query.String(), dollar...)

	log.Debug(stmt)
	log.Debug(args...)
	res, err := db.Exec(stmt, args...)
	if err != nil {
		log.Error(err)
		log.Error(stmt)
		log.Error(args...)
		return 0, err
	}
	return res.RowsAffected()
}

func (*DemoPersist) Get(id int) (*domain.Demo, error) {
	var err error
	query, args := bytes.NewBuffer([]byte{}), []interface{}{}
	var stmt string

	stmt = "select id, name, third_field, status, content from demos where id=$%d "
	args = append(args, id)
	query.WriteString(stmt)

	var dollar []interface{}
	for i := range args {
		dollar = append(dollar, i+1)
	}
	stmt = fmt.Sprintf(query.String(), dollar...)

	log.Debug(stmt)
	log.Debug(args...)
	var _x domain.Demo

	var _x_Content []byte

	dest := []interface{}{&_x.Id, &_x.Name, &_x.ThirdField, &_x.Status, &_x_Content}

	err = db.QueryRow(stmt, args...).Scan(dest...)
	if err != nil {
		log.Error(err)
		log.Error(stmt)
		log.Error(args...)
		return nil, err
	}
	_x.Content = &domain.Demo{}
	err = json.Unmarshal(_x_Content, &_x.Content)
	if err != nil {
		log.Error(err)
		log.Error(stmt)
		log.Error(args...)
	}
	return &_x, nil
}

func (*DemoPersist) Count(tx *sql.Tx, d *domain.Demo, statuses []enums.Status) (int64, error) {
	var err error
	query, args := bytes.NewBuffer([]byte{}), []interface{}{}
	var stmt string

	stmt = "select count(id) from demos where name=$%d "
	args = append(args, d.Name)
	query.WriteString(stmt)

	if d.ThirdField != false {
		stmt = "and third_field=$%d "
		args = append(args, d.ThirdField)
		query.WriteString(stmt)
	}

	if d.Content != nil {
		stmt = "and content=$%d "
		d_Content, err := json.Marshal(d.Content)
		if err != nil {
			log.Errorf("marshal(%#v) error: %s", d.Content, err)
		}
		args = append(args, d_Content)
		query.WriteString(stmt)
	}

	if len(statuses) != 0 {
		stmt = "and status in ($%d) "
		for _, v := range statuses {
			args = append(args, int8(v))
		}
		stmt = strings.Replace(stmt, "$%d",
			strings.Repeat(",$%d", len(statuses))[1:], -1)
		query.WriteString(stmt)
	}

	var dollar []interface{}
	for i := range args {
		dollar = append(dollar, i+1)
	}
	stmt = fmt.Sprintf(query.String(), dollar...)

	log.Debug(stmt)
	log.Debug(args...)
	var _x int64
	err = tx.QueryRow(stmt, args...).Scan(&_x)
	if err != nil {
		log.Error(err)
		log.Error(stmt)
		log.Error(args...)
		return 0, err
	}
	return _x, nil
}

func (*DemoPersist) List(tx *sql.Tx, d *domain.Demo, statuses []enums.Status, offset int, limit int) ([]*domain.Demo, error) {
	var err error
	query, args := bytes.NewBuffer([]byte{}), []interface{}{}
	var stmt string

	stmt = "select id, name, third_field, status, content from demos where name=$%d "
	args = append(args, d.Name)
	query.WriteString(stmt)

	if d.ThirdField != false {
		stmt = "and third_field=$%d "
		args = append(args, d.ThirdField)
		query.WriteString(stmt)
	}

	if d.Content != nil {
		stmt = "and content=$%d "
		d_Content, err := json.Marshal(d.Content)
		if err != nil {
			log.Errorf("marshal(%#v) error: %s", d.Content, err)
		}
		args = append(args, d_Content)
		query.WriteString(stmt)
	}

	if len(statuses) != 0 {
		stmt = "and status in ($%d) "
		for _, v := range statuses {
			args = append(args, int8(v))
		}
		stmt = strings.Replace(stmt, "$%d",
			strings.Repeat(",$%d", len(statuses))[1:], -1)
		query.WriteString(stmt)
	}

	stmt = "order by id offset $%d limit $%d "
	args = append(args, offset)
	args = append(args, limit)
	query.WriteString(stmt)

	var dollar []interface{}
	for i := range args {
		dollar = append(dollar, i+1)
	}
	stmt = fmt.Sprintf(query.String(), dollar...)

	log.Debug(stmt)
	log.Debug(args...)
	rows, err := tx.Query(stmt, args...)
	if err != nil {
		log.Error(err)
		log.Error(stmt)
		log.Error(args...)
		return nil, err
	}
	defer rows.Close()

	var xs []*domain.Demo
	for rows.Next() {
		var _x domain.Demo
		xs = append(xs, &_x)

		var _x_Content []byte

		dest := []interface{}{&_x.Id, &_x.Name, &_x.ThirdField, &_x.Status, &_x_Content}

		err = rows.Scan(dest...)
		if err != nil {
			log.Error(err)
			log.Error(stmt)
			log.Error(args...)
			return nil, err
		}
		_x.Content = &domain.Demo{}
		err = json.Unmarshal(_x_Content, &_x.Content)
		if err != nil {
			log.Errorf("unmarshal(%s) error: %s", _x_Content, err)
		}
	}
	if err = rows.Err(); err != nil {
		log.Error(err)
		log.Error(stmt)
		log.Error(args...)
		return nil, err
	}
	return xs, nil
}
