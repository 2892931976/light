// DO NOT EDIT THIS FILE !
// It is generated by gobatis tool, source from model.go.
package mapper

import (
	"bytes"
	"database/sql"
	"encoding/json"
	"fmt"
	"strconv"
	"strings"

	"github.com/arstd/gobatis/examples/domain"
	e "github.com/arstd/gobatis/examples/enums"
	"github.com/wothing/log"
)

type ModelMapperImpl struct{}

func (*ModelMapperImpl) Insert(tx *sql.Tx, m *domain.Model) (err error) {
	var (
		stmt string
		buf  bytes.Buffer
		args []interface{}
	)

	stmt = `insert into models(buildin_bool, buildin_byte, buildin_float32, buildin_float64, buildin_int, buildin_int16, buildin_int32, buildin_int64, buildin_int8, buildin_rune, buildin_string, buildin_uint, buildin_uint16, buildin_uint32, buildin_uint64, buildin_uint8, buildin_map, enum_status, ptr_model, time, slice, struct_slice) values (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) returning id `
	args = append(args, m.BuildinBool)
	args = append(args, m.BuildinByte)
	args = append(args, m.BuildinFloat32)
	args = append(args, m.BuildinFloat64)
	args = append(args, m.BuildinInt)
	args = append(args, m.BuildinInt16)
	args = append(args, m.BuildinInt32)
	args = append(args, m.BuildinInt64)
	args = append(args, m.BuildinInt8)
	args = append(args, m.BuildinRune)
	args = append(args, m.BuildinString)
	args = append(args, m.BuildinUint)
	args = append(args, m.BuildinUint16)
	args = append(args, m.BuildinUint32)
	args = append(args, m.BuildinUint64)
	args = append(args, m.BuildinUint8)
	var xm_BuildinMap []byte
	xm_BuildinMap, err = json.Marshal(m.BuildinMap)
	if err != nil {
		log.Error(err)
		return
	}
	args = append(args, xm_BuildinMap)
	args = append(args, int32(m.EnumStatus))
	var xm_PtrModel []byte
	xm_PtrModel, err = json.Marshal(m.PtrModel)
	if err != nil {
		log.Error(err)
		return
	}
	args = append(args, xm_PtrModel)
	args = append(args, m.Time)
	var xm_Slice []byte
	xm_Slice, err = json.Marshal(m.Slice)
	if err != nil {
		log.Error(err)
		return
	}
	args = append(args, xm_Slice)
	var xm_StructSlice []byte
	xm_StructSlice, err = json.Marshal(m.StructSlice)
	if err != nil {
		log.Error(err)
		return
	}
	args = append(args, xm_StructSlice)
	buf.WriteString(stmt)

	var ph []interface{}
	for i := range args {
		ph = append(ph, "$"+strconv.Itoa(i+1))
	}

	query := fmt.Sprintf(buf.String(), ph...)

	log.Debug(query)
	log.Debug(args...)

	var dest []interface{}

	dest = append(dest, &m.Id)

	err = tx.QueryRow(query, args...).Scan(dest...)
	if err != nil {
		log.Error(err)
		log.Error(query)
		log.Error(args...)
		return
	}

	return nil

}
func (*ModelMapperImpl) Update(tx *sql.Tx, m *domain.Model) (xi int64, err error) {
	var (
		stmt string
		buf  bytes.Buffer
		args []interface{}
	)

	stmt = `update models set buildin_bool=%s, buildin_byte=%s, buildin_float32=%s, buildin_float64=%s, buildin_int=%s, buildin_int16=%s, buildin_int32=%s, buildin_int64=%s, buildin_int8=%s, buildin_rune=%s, buildin_string=%s, buildin_uint=%s, buildin_uint16=%s, buildin_uint32=%s, buildin_uint64=%s, buildin_uint8=%s, buildin_map=%s, enum_status=%s, ptr_model=%s, time=%s, slice=%s, struct_slice=%s where id=%s `
	args = append(args, m.BuildinBool)
	args = append(args, m.BuildinByte)
	args = append(args, m.BuildinFloat32)
	args = append(args, m.BuildinFloat64)
	args = append(args, m.BuildinInt)
	args = append(args, m.BuildinInt16)
	args = append(args, m.BuildinInt32)
	args = append(args, m.BuildinInt64)
	args = append(args, m.BuildinInt8)
	args = append(args, m.BuildinRune)
	args = append(args, m.BuildinString)
	args = append(args, m.BuildinUint)
	args = append(args, m.BuildinUint16)
	args = append(args, m.BuildinUint32)
	args = append(args, m.BuildinUint64)
	args = append(args, m.BuildinUint8)
	var xm_BuildinMap []byte
	xm_BuildinMap, err = json.Marshal(m.BuildinMap)
	if err != nil {
		log.Error(err)
		return
	}
	args = append(args, xm_BuildinMap)
	args = append(args, int32(m.EnumStatus))
	var xm_PtrModel []byte
	xm_PtrModel, err = json.Marshal(m.PtrModel)
	if err != nil {
		log.Error(err)
		return
	}
	args = append(args, xm_PtrModel)
	args = append(args, m.Time)
	var xm_Slice []byte
	xm_Slice, err = json.Marshal(m.Slice)
	if err != nil {
		log.Error(err)
		return
	}
	args = append(args, xm_Slice)
	var xm_StructSlice []byte
	xm_StructSlice, err = json.Marshal(m.StructSlice)
	if err != nil {
		log.Error(err)
		return
	}
	args = append(args, xm_StructSlice)
	args = append(args, m.Id)
	buf.WriteString(stmt)

	var ph []interface{}
	for i := range args {
		ph = append(ph, "$"+strconv.Itoa(i+1))
	}

	query := fmt.Sprintf(buf.String(), ph...)

	log.Debug(query)
	log.Debug(args...)

	res, err := db.Exec(query, args...)
	if err != nil {
		log.Error(err)
		log.Error(query)
		log.Error(args...)
		return 0, err
	}
	return res.RowsAffected()

}
func (*ModelMapperImpl) Delete(tx *sql.Tx, id int) (xi int64, err error) {
	var (
		stmt string
		buf  bytes.Buffer
		args []interface{}
	)

	stmt = `delete from models where id=%s `
	args = append(args, id)
	buf.WriteString(stmt)

	var ph []interface{}
	for i := range args {
		ph = append(ph, "$"+strconv.Itoa(i+1))
	}

	query := fmt.Sprintf(buf.String(), ph...)

	log.Debug(query)
	log.Debug(args...)

	res, err := db.Exec(query, args...)
	if err != nil {
		log.Error(err)
		log.Error(query)
		log.Error(args...)
		return 0, err
	}
	return res.RowsAffected()
}
func (*ModelMapperImpl) Get(tx *sql.Tx, id int) (xm *domain.Model, err error) {
	var (
		stmt string
		buf  bytes.Buffer
		args []interface{}
	)

	stmt = `select id, buildin_bool, buildin_byte, buildin_float32, buildin_float64, buildin_int, buildin_int16, buildin_int32, buildin_int64, buildin_int8, buildin_rune, buildin_string, buildin_uint, buildin_uint16, buildin_uint32, buildin_uint64, buildin_uint8, buildin_map, enum_status, ptr_model, time, slice, struct_slice from models where id=%s `
	args = append(args, id)
	buf.WriteString(stmt)

	var ph []interface{}
	for i := range args {
		ph = append(ph, "$"+strconv.Itoa(i+1))
	}

	query := fmt.Sprintf(buf.String(), ph...)

	log.Debug(query)
	log.Debug(args...)

	var dest []interface{}
	xm = &domain.Model{}
	dest = append(dest, &xm.Id)
	dest = append(dest, &xm.BuildinBool)
	dest = append(dest, &xm.BuildinByte)
	dest = append(dest, &xm.BuildinFloat32)
	dest = append(dest, &xm.BuildinFloat64)
	dest = append(dest, &xm.BuildinInt)
	dest = append(dest, &xm.BuildinInt16)
	dest = append(dest, &xm.BuildinInt32)
	dest = append(dest, &xm.BuildinInt64)
	dest = append(dest, &xm.BuildinInt8)
	dest = append(dest, &xm.BuildinRune)
	dest = append(dest, &xm.BuildinString)
	dest = append(dest, &xm.BuildinUint)
	dest = append(dest, &xm.BuildinUint16)
	dest = append(dest, &xm.BuildinUint32)
	dest = append(dest, &xm.BuildinUint64)
	dest = append(dest, &xm.BuildinUint8)
	var xxm_BuildinMap []byte
	dest = append(dest, &xxm_BuildinMap)
	dest = append(dest, &xm.EnumStatus)
	var xxm_PtrModel []byte
	dest = append(dest, &xxm_PtrModel)
	dest = append(dest, &xm.Time)
	var xxm_Slice []byte
	dest = append(dest, &xxm_Slice)
	var xxm_StructSlice []byte
	dest = append(dest, &xxm_StructSlice)
	err = db.QueryRow(query, args...).Scan(dest...)
	if err != nil {
		log.Error(err)
		log.Error(query)
		log.Error(args...)
		return
	}
	xm.BuildinMap = map[string]interface{}{}
	err = json.Unmarshal(xxm_BuildinMap, &xm.BuildinMap)
	if err != nil {
		log.Error(err)
		return
	}
	xm.PtrModel = &domain.Model{}
	err = json.Unmarshal(xxm_PtrModel, &xm.PtrModel)
	if err != nil {
		log.Error(err)
		return
	}
	xm.Slice = []string{}
	err = json.Unmarshal(xxm_Slice, &xm.Slice)
	if err != nil {
		log.Error(err)
		return
	}
	xm.StructSlice = []*domain.Model{}
	err = json.Unmarshal(xxm_StructSlice, &xm.StructSlice)
	if err != nil {
		log.Error(err)
		return
	}
	return
}
func (*ModelMapperImpl) Count(tx *sql.Tx, m *domain.Model, ss []e.Status) (xi int64, err error) {
	var (
		stmt string
		buf  bytes.Buffer
		args []interface{}
	)

	stmt = `select count(*) from models where buildin_bool=%s `
	args = append(args, m.BuildinBool)
	buf.WriteString(stmt)

	if m.BuildinInt != 0 {
		stmt = `and buildin_int=%s  `
		args = append(args, m.BuildinInt)
		buf.WriteString(stmt)
	}
	if len(ss) != 0 {
		stmt = `and enum_status in (${ss})  `
		stmt = strings.Replace(stmt, "${"+"ss"+"}",
			strings.Repeat(",%s", len(ss))[1:], -1)
		for _, s := range ss {
			args = append(args, s)
		}
		buf.WriteString(stmt)
	}

	var ph []interface{}
	for i := range args {
		ph = append(ph, "$"+strconv.Itoa(i+1))
	}

	query := fmt.Sprintf(buf.String(), ph...)

	log.Debug(query)
	log.Debug(args...)

	var dest []interface{}
	dest = append(dest, &xi)
	err = db.QueryRow(query, args...).Scan(dest...)
	if err != nil {
		log.Error(err)
		log.Error(query)
		log.Error(args...)
		return
	}
	return
}
func (*ModelMapperImpl) List(tx *sql.Tx, m *domain.Model, ss []e.Status, offset int, limit int) (xms []*domain.Model, err error) {
	var (
		stmt string
		buf  bytes.Buffer
		args []interface{}
	)

	stmt = `select id, buildin_bool, buildin_byte, buildin_float32, buildin_float64, buildin_int, buildin_int16, buildin_int32, buildin_int64, buildin_int8, buildin_rune, buildin_string, buildin_uint, buildin_uint16, buildin_uint32, buildin_uint64, buildin_uint8, buildin_map, enum_status, ptr_model, time, slice, struct_slice from models where buildin_bool=%s `
	args = append(args, m.BuildinBool)
	buf.WriteString(stmt)

	if m.BuildinInt != 0 {
		stmt = `and buildin_int=%s  `
		args = append(args, m.BuildinInt)
		buf.WriteString(stmt)
	}
	if len(ss) != 0 {
		stmt = `and enum_status in (${ss})  `
		stmt = strings.Replace(stmt, "${"+"ss"+"}",
			strings.Repeat(",%s", len(ss))[1:], -1)
		for _, s := range ss {
			args = append(args, s)
		}
		buf.WriteString(stmt)
	}

	stmt = `order by id offset %s limit %s `
	args = append(args, offset)
	args = append(args, limit)
	buf.WriteString(stmt)

	var ph []interface{}
	for i := range args {
		ph = append(ph, "$"+strconv.Itoa(i+1))
	}

	query := fmt.Sprintf(buf.String(), ph...)

	log.Debug(query)
	log.Debug(args...)

	rows, err := db.Query(query, args...)
	if err != nil {
		log.Error(err)
		return nil, err
	}
	defer rows.Close()

	var data []*domain.Model
	for rows.Next() {
		x := &domain.Model{}
		data = append(data, x)

		var dest []interface{}
		dest = append(dest, &x.Id)
		dest = append(dest, &x.BuildinBool)
		dest = append(dest, &x.BuildinByte)
		dest = append(dest, &x.BuildinFloat32)
		dest = append(dest, &x.BuildinFloat64)
		dest = append(dest, &x.BuildinInt)
		dest = append(dest, &x.BuildinInt16)
		dest = append(dest, &x.BuildinInt32)
		dest = append(dest, &x.BuildinInt64)
		dest = append(dest, &x.BuildinInt8)
		dest = append(dest, &x.BuildinRune)
		dest = append(dest, &x.BuildinString)
		dest = append(dest, &x.BuildinUint)
		dest = append(dest, &x.BuildinUint16)
		dest = append(dest, &x.BuildinUint32)
		dest = append(dest, &x.BuildinUint64)
		dest = append(dest, &x.BuildinUint8)
		var xx_BuildinMap []byte
		dest = append(dest, &xx_BuildinMap)
		dest = append(dest, &x.EnumStatus)
		var xx_PtrModel []byte
		dest = append(dest, &xx_PtrModel)
		dest = append(dest, &x.Time)
		var xx_Slice []byte
		dest = append(dest, &xx_Slice)
		var xx_StructSlice []byte
		dest = append(dest, &xx_StructSlice)
		err = rows.Scan(dest...)
		if err != nil {
			log.Error(err)
			return nil, err
		}
		x.BuildinMap = map[string]interface{}{}
		err = json.Unmarshal(xx_BuildinMap, &x.BuildinMap)
		if err != nil {
			log.Error(err)
			return
		}
		x.PtrModel = &domain.Model{}
		err = json.Unmarshal(xx_PtrModel, &x.PtrModel)
		if err != nil {
			log.Error(err)
			return
		}
		x.Slice = []string{}
		err = json.Unmarshal(xx_Slice, &x.Slice)
		if err != nil {
			log.Error(err)
			return
		}
		x.StructSlice = []*domain.Model{}
		err = json.Unmarshal(xx_StructSlice, &x.StructSlice)
		if err != nil {
			log.Error(err)
			return
		}
	}
	if err = rows.Err(); err != nil {
		log.Error(err)
		return nil, err
	}

	return data, nil
}
