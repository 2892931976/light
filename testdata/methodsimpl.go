// DO NOT EDIT THIS FILE!
// It is generated by `light` tool by source `methods.go` at 2017-03-16 16:06:19.

package testdata

import (
	"bytes"
	"database/sql"
	"fmt"

	"github.com/arstd/light/example/enum"
	"github.com/arstd/light/example/model"
	"github.com/arstd/log"
)

type Interface1Impl struct{}

// batch: insert into model(id, name, flag, score, map, time, slice, status, pointer, struct_slice, uint32) values [{ i, m := range ms | , } (${i}, ${m.Name}, ${m.Flag}, ${m.Score}, ${m.Map}, ${m.Time}, ${m.Slice}, ${m.Status}, ${m.Pointer}, ${m.StructSlice}, ${m.Uint32}) ]
func (*Interface1Impl) BatchInsert(tx *sql.Tx, ms []*model.Model) (i int64, err error) {
	var (
		buf  bytes.Buffer
		args []interface{}
	)
	// insert into model(id, name, flag, score, map, time, slice, status, pointer, struct_slice, uint32) values
	buf.WriteString(`insert into model(id, name, flag, score, map, time, slice, status, pointer, struct_slice, uint32) values`)
	// (${i}, ${m.Name}, ${m.Flag}, ${m.Score}, ${m.Map}, ${m.Time}, ${m.Slice}, ${m.Status}, ${m.Pointer}, ${m.StructSlice}, ${m.Uint32})
	for i, m := range ms {
		if i != 0 {
			buf.WriteString(",")
		}
		buf.WriteString(`(%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)`)
		args = append(args, i)
		args = append(args, m.Name)
		args = append(args, m.Flag)
		args = append(args, m.Score)
		args = append(args, m.Map)
		args = append(args, m.Time)
		args = append(args, m.Slice)
		args = append(args, m.Status)
		args = append(args, m.Pointer)
		args = append(args, m.StructSlice)
		args = append(args, m.Uint32)
	}

	ph := make([]string, len(args))
	for i := range args {
		ph[i] = fmt.Sprintf("$%d", i+1)
	}
	query := fmt.Sprintf(buf.string(), ph...)

	log.Debug(query)
	log.Debug(args...)
	res, err := db.Exec(query, args...)
	if err != nil {
		log.Error(query)
		log.Error(args...)
		log.Error(err)
	}
	return res.RowsAffected()

}

// insert: insert into model(name, flag, score, map, time, slice, status, pointer, struct_slice, uint32) values (${m.Name}, ${m.Flag}, ${m.Score}, ${m.Map}, ${m.Time}, ${m.Slice}, ${m.Status}, ${m.Pointer}, ${m.StructSlice}, ${m.Uint32}) returning id
func (*Interface1Impl) Insert(tx *sql.Tx, m *model.Model) (err error) {
	var (
		buf  bytes.Buffer
		args []interface{}
	)
	// insert into model(name, flag, score, map, time, slice, status, pointer, struct_slice, uint32) values (${m.Name}, ${m.Flag}, ${m.Score}, ${m.Map}, ${m.Time}, ${m.Slice}, ${m.Status}, ${m.Pointer}, ${m.StructSlice}, ${m.Uint32}) returning id
	buf.WriteString(`insert into model(name, flag, score, map, time, slice, status, pointer, struct_slice, uint32) values (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s) returning id`)
	args = append(args, m.Name)
	args = append(args, m.Flag)
	args = append(args, m.Score)
	args = append(args, m.Map)
	args = append(args, m.Time)
	args = append(args, m.Slice)
	args = append(args, m.Status)
	args = append(args, m.Pointer)
	args = append(args, m.StructSlice)
	args = append(args, m.Uint32)

	ph := make([]string, len(args))
	for i := range args {
		ph[i] = fmt.Sprintf("$%d", i+1)
	}
	query := fmt.Sprintf(buf.string(), ph...)

	log.Debug(query)
	log.Debug(args...)
	m = &model.Model{}
	dest := make([]interface{}, 1)

	dest[0] = &m.Id
	err = db.QueryRow(query, args...).Scan(dest...)
	if err != nil {
		log.Error(err)
		log.Error(query)
		log.Error(args...)
		return
	}
	return

}

// list: select id, name, flag, score, map, time, slice, status, pointer, struct_slice, uint32 from model where name like ${m.Name} [{ m.Flag != false } [{ m.Status != 0 } status=${m.Status} ] and flag=${m.Flag} ] [{ len(ss) != 0 } and status in ([{range ss}]) ] [{ len(m.Slice) != 0 } and slice ?| array[[{range m.Slice}]] ] order by id offset ${offset} limit ${limit}
func (*Interface1Impl) List(tx *sql.Tx, m *model.Model, ss []enum.Status, offset int, limit int) (ms []*model.Model, err error) {
	var (
		buf  bytes.Buffer
		args []interface{}
	)
	// select id, name, flag, score, map, time, slice, status, pointer, struct_slice, uint32 from model where name like ${m.Name}
	buf.WriteString(`select id, name, flag, score, map, time, slice, status, pointer, struct_slice, uint32 from model where name like %s`)
	args = append(args, m.Name)
	// [{ m.Status != 0 } status=${m.Status} ] and flag=${m.Flag}
	if m.Flag != false {
		// status=${m.Status}
		if m.Status != 0 {
			buf.WriteString(`status=%s`)
			args = append(args, m.Status)
		}
		// and flag=${m.Flag}
		buf.WriteString(`and flag=%s`)
		args = append(args, m.Flag)
	}
	// and status in ([{range ss}])
	if len(ss) != 0 {
		// and status in (
		buf.WriteString(`and status in (`)
		// ${v}
		for i, v := range ss {
			if i != 0 {
				buf.WriteString(",")
			}
			buf.WriteString(`%s`)
			args = append(args, v)
		}
		// )
		buf.WriteString(`)`)
	}
	// and slice ?| array[[{range m.Slice}]]
	if len(m.Slice) != 0 {
		// and slice ?| array[
		buf.WriteString(`and slice ?| array[`)
		// ${v}
		for i, v := range m.Slice {
			if i != 0 {
				buf.WriteString(",")
			}
			buf.WriteString(`%s`)
			args = append(args, v)
		}
		// ]
		buf.WriteString(`]`)
	}
	// order by id offset ${offset} limit ${limit}
	buf.WriteString(`order by id offset %s limit %s`)
	args = append(args, offset)
	args = append(args, limit)

	ph := make([]string, len(args))
	for i := range args {
		ph[i] = fmt.Sprintf("$%d", i+1)
	}
	query := fmt.Sprintf(buf.string(), ph...)

	log.Debug(query)
	log.Debug(args...)
	var rows *sql.Rows
	rows, err = db.Query(query, args...)
	if err != nil {
		log.Error(err)
		log.Error(query)
		log.Error(args...)
		return
	}
	defer rows.Close()

	ms = []*model.Model{}
	for rows.Next() {
		elem := &model.Model{}
		ms = append(ms, elem)
		dest := make([]interface{}, 11)
		dest[0] = &elem.Id
		dest[1] = &elem.Name
		dest[2] = &elem.Flag
		dest[3] = &elem.Score
		dest[4] = &elem.Map
		dest[5] = &elem.Time
		dest[6] = &elem.Slice
		dest[7] = &elem.Status
		dest[8] = &elem.Pointer
		dest[9] = &elem.StructSlice
		dest[10] = &elem.Uint32
		err = rows.Scan(dest...)
		if err != nil {
			log.Error(err)
			return
		}
	}
	if err = rows.Err(); err != nil {
		log.Error(err)
		return
	}
	return

}
