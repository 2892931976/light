// DO NOT EDIT THIS FILE!
// It is generated by `light` tool by source `methods.go` at 2017-03-15 18:05:56.

package testdata

import (
	"bytes"

	sql "database/sql"

	enum "github.com/arstd/light/example/enum"
	model "github.com/arstd/light/example/model"
)

type Interface1Impl struct{}

// insert: insert into model(id, name, flag, score, map, time, slice, status, pointer, struct_slice, uint32) values [{ i, m := range ms | , } (${i}, ${m.Name}, ${m.Flag}, ${m.Score}, ${m.Map}, ${m.Time}, ${m.Slice}, ${m.Status}, ${m.Pointer}, ${m.StructSlice}, ${m.Uint32}) ] returning id
func (*Interface1Impl) BatchInsert(tx *sql.Tx, ms []*model.Model) (err error) {
	var (
		prepare string
		buf     bytes.Buffer
		args    []interface{}
	)
	// insert into model(id, name, flag, score, map, time, slice, status, pointer, struct_slice, uint32) values
	prepare = `insert into model(id, name, flag, score, map, time, slice, status, pointer, struct_slice, uint32) values`

	buf.WriteString(prepare)
	// (${i}, ${m.Name}, ${m.Flag}, ${m.Score}, ${m.Map}, ${m.Time}, ${m.Slice}, ${m.Status}, ${m.Pointer}, ${m.StructSlice}, ${m.Uint32})
	for _, m := range ms {
		var prepare string
		prepare = `(%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)`
		args = append(args, i)
		args = append(args, m.Name)
		args = append(args, m.Flag)
		args = append(args, m.Score)
		args = append(args, m.Map)
		args = append(args, m.Time)
		args = append(args, m.Slice)
		args = append(args, m.Status)
		args = append(args, m.Pointer)
		args = append(args, m.StructSlice)
		args = append(args, m.Uint32)

		buf.WriteString(prepare)
		buf.WriteString(",")
	}
	buf.Truncate(buf.Len() - len(","))
	// returning id
	prepare = `returning id`

	buf.WriteString(prepare)
}

// insert: insert into model(name, flag, score, map, time, slice, status, pointer, struct_slice, uint32) values (${m.Name}, ${m.Flag}, ${m.Score}, ${m.Map}, ${m.Time}, ${m.Slice}, ${m.Status}, ${m.Pointer}, ${m.StructSlice}, ${m.Uint32}) returning id
func (*Interface1Impl) Insert(tx *sql.Tx, m []*model.Model) (err error) {
	var (
		prepare string
		buf     bytes.Buffer
		args    []interface{}
	)
	// insert into model(name, flag, score, map, time, slice, status, pointer, struct_slice, uint32) values (${m.Name}, ${m.Flag}, ${m.Score}, ${m.Map}, ${m.Time}, ${m.Slice}, ${m.Status}, ${m.Pointer}, ${m.StructSlice}, ${m.Uint32}) returning id
	prepare = `insert into model(name, flag, score, map, time, slice, status, pointer, struct_slice, uint32) values (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s) returning id`
	args = append(args, m.Name)
	args = append(args, m.Flag)
	args = append(args, m.Score)
	args = append(args, m.Map)
	args = append(args, m.Time)
	args = append(args, m.Slice)
	args = append(args, m.Status)
	args = append(args, m.Pointer)
	args = append(args, m.StructSlice)
	args = append(args, m.Uint32)

	buf.WriteString(prepare)
}

// list: select id, name, flag, score, map, time, slice, status, pointer, struct_slice, uint32 from model where name like ${m.Name} [{ m.Flag != false } [{ m.Status != 0 } status=${m.Status} ] and flag=${m.Flag} ] [{ len(ss) != 0 } and status in ([{range ss}]) ] [{ len(m.Slice) != 0 } and slice ?| array[[{range m.Slice}]] ] order by id offset ${offset} limit ${limit}
func (*Interface1Impl) List(tx *sql.Tx, m []*model.Model, ss []enum.Status, offset int, limit int) (xmms []*model.Model, err error) {
	var (
		prepare string
		buf     bytes.Buffer
		args    []interface{}
	)
	// select id, name, flag, score, map, time, slice, status, pointer, struct_slice, uint32 from model where name like ${m.Name}
	prepare = `select id, name, flag, score, map, time, slice, status, pointer, struct_slice, uint32 from model where name like %s`
	args = append(args, m.Name)

	buf.WriteString(prepare)
	// [{ m.Status != 0 } status=${m.Status} ] and flag=${m.Flag}
	if m.Flag != false {
		var prepare string
		// status=${m.Status}
		if m.Status != 0 {
			var prepare string
			prepare = `status=%s`
			args = append(args, m.Status)

			buf.WriteString(prepare)
		}
		// and flag=${m.Flag}
		prepare = `and flag=%s`
		args = append(args, m.Flag)

		buf.WriteString(prepare)

		buf.WriteString(prepare)
	}
	// and status in ([{range ss}])
	if len(ss) != 0 {
		var prepare string
		// and status in (
		prepare = `and status in (`

		buf.WriteString(prepare)
		// ${v}
		for _, v := range ss {
			var prepare string
			prepare = `%s`
			args = append(args, v)

			buf.WriteString(prepare)
			buf.WriteString(",")
		}
		buf.Truncate(buf.Len() - len(","))
		// )
		prepare = `)`

		buf.WriteString(prepare)

		buf.WriteString(prepare)
	}
	// and slice ?| array[[{range m.Slice}]]
	if len(m.Slice) != 0 {
		var prepare string
		// and slice ?| array[
		prepare = `and slice ?| array[`

		buf.WriteString(prepare)
		// ${v}
		for _, v := range m.Slice {
			var prepare string
			prepare = `%s`
			args = append(args, v)

			buf.WriteString(prepare)
			buf.WriteString(",")
		}
		buf.Truncate(buf.Len() - len(","))
		// ]
		prepare = `]`

		buf.WriteString(prepare)

		buf.WriteString(prepare)
	}
	// order by id offset ${offset} limit ${limit}
	prepare = `order by id offset %s limit %s`
	args = append(args, offset)
	args = append(args, limit)

	buf.WriteString(prepare)
}
