
// DO NOT EDIT THIS FILE!
// It is generated by `light` tool by source `{{.Source}}` at {{timestamp}}.

package {{.Name}}

import (
    "bytes"
    "encoding/json"
    "fmt"
    "github.com/arstd/log"
    {{- range $v := .Imports}}
        "{{$v}}"
    {{- end}}
)

{{- range .Interfaces}}
    {{- $itf := .}}

    type {{$itf.Name}}Impl struct{}

    {{- range .Methods}}
        // {{.Kind}}: {{.Doc}}
        func (*{{$itf.Name}}Impl) {{.Name}}({{.ParamsExpr}})({{.ResultsExpr}}) {
            var (
                buf  bytes.Buffer
                args []interface{}
            )

            {{- block "fragments" .Fragments}}
                {{- range .}}
                    // {{.Stmt}}
                    {{- if .Range}}
                        for i, {{.Iterator.Var}} := range {{.Range.Var}} {
                            if i != 0 {
                                buf.WriteString("{{.Seperator}}")
                            }
                    {{- else if .Cond}}
                        if {{.Cond}} {
                    {{- end}}

                            {{- if .Prepare}}
                                buf.WriteString(`{{.Prepare}}`)
                            {{- end}}

                            {{- range .Args}}
                                {{- if .DBType.Array}}
                                    {{.Var2}} := bytes.NewBufferString("{")
                                    for _, v := range {{.Var}} {
                                        {{.Var2}}.WriteString(fmt.Sprint(v))
                                        {{.Var2}}.WriteRune(',')
                                    }
                                    {{.Var2}}.Truncate({{.Var2}}.Len()-1)
                                    {{.Var2}}.WriteRune('}')
                                    args = append(args, {{.Var2}}.String())
                                {{- else if .Complex}}
                                    {{.Var2}}, _ := json.Marshal({{.Var}})
                                    args = append(args, {{.Var2}})
                                {{- else}}
                                    args = append(args, {{.Var}})
                                {{- end}}
                            {{- end}}

                            {{- template "fragments" .Fragments}}

                    {{- if .Range}}
                        }
                    {{- else if .Cond}}
                        }
                    {{- end}}

                {{- end}}{{/* end range fragments */}}
            {{- end}}{{/* end fragments block */}}

            ph := make([]interface{}, len(args))
            for i := range args {
                ph[i] = fmt.Sprintf("$%d", i+1)
            }
            query := fmt.Sprintf(buf.String(), ph...)

            log.Debug(query)
            log.Debug(args...)

            {{- if or (eq .Kind "batch") (eq .Kind "update") (eq .Kind "delete")}}
                res, err := db.Exec(query, args...)
                if err != nil {
                    log.Error(query)
                    log.Error(args...)
                    log.Error(err)
                }
                return res.RowsAffected()

            {{/* end batch method */}}
            {{- else if or (eq .Kind "get") (eq .Kind "insert")}}
                {{.Return.Var}} = {{.Return.MakeExpr}}
                dest := make([]interface{}, {{len .Returnings}})
                {{$Return := .Return}}
                {{- range $i, $r := .Returnings}}
                    dest[{{$i}}] = &{{$Return.Var}}.{{$r.Var}}
                {{- end}}
                err = db.QueryRow(query, args...).Scan(dest...)
                if err != nil {
            		log.Error(err)
            		log.Error(query)
            		log.Error(args...)
                    return
            	}
                return

            {{/* end batch method */}}
            {{- else if eq .Kind "list"}}
                var rows *sql.Rows
                rows, err = db.Query(query, args...)
                if err != nil {
                    log.Error(err)
                    log.Error(query)
                    log.Error(args...)
                    return
                }
                defer rows.Close()

                {{.Return.Var}} = {{.Return.MakeExpr}}
                for rows.Next() {
                    elem := {{.Return.MakeElemExpr}}
                    {{.Return.Var}} = append({{.Return.Var}}, elem)
                    dest := make([]interface{}, {{len .Returnings}})
                    {{- range $i, $r := .Returnings}}
                        dest[{{$i}}] = &elem.{{$r.Var}}
                    {{- end}}
                    err = rows.Scan(dest...)
                    if err != nil {
                        log.Error(err)
                        return
                    }
                }
                if err = rows.Err(); err != nil {
                    log.Error(err)
                    return
                }
                return

            {{/* end batch method */}}
            {{- else if eq .Kind "page"}}
                // TODO page template not implement
                return

            {{/* end page method */}}
            {{- else if eq .Kind "count"}}
                // TODO page template not implement
                return
            {{end}}
        }
    {{- end}}{{/* end range methods */}}

{{- end}}{{/* end range interfaces */}}
